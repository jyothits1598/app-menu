import { __awaiter } from "tslib";
import { ChangeDetectorRef, Component, ElementRef, EventEmitter, Inject, Injector, Input, Output } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NGX_GOOGLE_PLACES_AUTOCOMPLETE_CONFIG } from './ngx-google-places-autocomplete.config';
import { NgxGooglePlacesAutocompleteControlValueAccessor } from './ngx-google-places-autocomplete.control-value-accessor';
export class NgxGooglePlacesAutocompleteComponent extends NgxGooglePlacesAutocompleteControlValueAccessor {
    constructor(changeDetectorRef, elementRef, injector, ngxGooglePlacesAutocompleteConfig) {
        super(injector);
        this.changeDetectorRef = changeDetectorRef;
        this.elementRef = elementRef;
        this.ngxGooglePlacesAutocompleteConfig = ngxGooglePlacesAutocompleteConfig;
        this.index = -1;
        this.predictions = [];
        this.show = false;
        this.placeholder = 'Enter a location';
        this.scriptLoaded = new EventEmitter();
        this.initialize().then(() => this.service = new google.maps.places.AutocompleteService());
    }
    onBlur() {
        this.reset(true);
    }
    onClick() {
        this.control.setValue(null);
    }
    onFocus() {
        this.reset(true, true);
    }
    onKeyDown(event) {
        if (!this.show)
            return;
        switch (event.key) {
            case 'ArrowDown':
                this.index += 1;
                if (this.index >= this.predictions.length)
                    this.index = this.predictions.length - 1;
                break;
            case 'ArrowUp':
                this.index -= 1;
                if (this.index < 0)
                    this.index = 0;
                break;
            case 'Escape':
                this.reset(true);
                break;
            case 'Enter':
                this.index !== -1 ? this.onMouseDown(this.predictions[this.index]) : this.reset(true);
                break;
        }
    }
    onModelChange(input) {
        if (!input) {
            this.reset();
            return;
        }
        const request = Object.assign({ input }, this.ngxGooglePlacesAutocompleteConfig.options);
        this.service.getPlacePredictions(request, (predictions, status) => {
            if (status !== google.maps.places.PlacesServiceStatus.OK) {
                this.reset();
                return;
            }
            this.predictions = predictions;
            this.show = true;
            this.changeDetectorRef.detectChanges();
        });
    }
    onMouseDown(prediction, event) {
        this.control.setValue(prediction.description, { emitViewToModelChange: false });
        if (event)
            this.dispatchEvent(event);
        this.reset(true);
    }
    dispatchEvent(event) {
        let customEvent;
        if (window.CustomEvent) {
            customEvent = new CustomEvent('submit', { bubbles: true, cancelable: true, detail: event });
        }
        else {
            customEvent = document.createEvent('CustomEvent');
            customEvent.initCustomEvent('submit', true, true, { data: event });
        }
        this.elementRef.nativeElement.firstElementChild.firstElementChild.form.dispatchEvent(customEvent);
    }
    initialize() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = window.google) === null || _a === void 0 ? void 0 : _a.maps)
                return new Promise((resolve) => resolve());
            return new Promise((resolve, reject) => {
                window['ngxGooglePlacesAutocompleteCallback'] = () => { this.scriptLoaded.emit(true); resolve(); };
                const script = document.createElement('script');
                script.async = true;
                script.defer = true;
                script.onerror = (err) => reject(err);
                script.src = `https://maps.googleapis.com/maps/api/js?callback=ngxGooglePlacesAutocompleteCallback&key=${this.ngxGooglePlacesAutocompleteConfig.key}&language=${this.ngxGooglePlacesAutocompleteConfig.language}&libraries=${this.ngxGooglePlacesAutocompleteConfig.libraries}&region=${this.ngxGooglePlacesAutocompleteConfig.region}`;
                script.type = 'text/javascript';
                document.body.appendChild(script);
            });
        });
    }
    reset(keep = false, show = false) {
        this.index = -1;
        if (!keep)
            this.predictions = [];
        this.show = show && this.predictions.length > 0;
    }
}
NgxGooglePlacesAutocompleteComponent.decorators = [
    { type: Component, args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: NgxGooglePlacesAutocompleteComponent, multi: true }],
                selector: 'ngx-google-places-autocomplete',
                template: "<div>\n  <input autocomplete=\"off\" (blur)=\"onBlur()\" (focus)=\"onFocus()\" [formControl]=\"control\" (keydown)=\"onKeyDown($event)\" (ngModelChange)=\"onModelChange($event)\" [placeholder]=\"placeholder\" type=\"text\" />\n  <button (click)=\"onClick()\" *ngIf=\"control.value\" type=\"button\">&times;</button>\n</div>\n<ul *ngIf=\"show\">\n  <li [class.selected]=\"i === index\" [innerHTML]=\"prediction.innerHTML\" (mousedown)=\"onMouseDown(prediction, $event)\" *ngFor=\"let prediction of predictions | highlight; let i = index\"></li>\n</ul>"
            },] }
];
NgxGooglePlacesAutocompleteComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: [NGX_GOOGLE_PLACES_AUTOCOMPLETE_CONFIG,] }] }
];
NgxGooglePlacesAutocompleteComponent.propDecorators = {
    placeholder: [{ type: Input }],
    scriptLoaded: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWdvb2dsZS1wbGFjZXMtYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL25neC1nb29nbGUtcGxhY2VzLWF1dG9jb21wbGV0ZS9saWIvbmd4LWdvb2dsZS1wbGFjZXMtYXV0b2NvbXBsZXRlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4SCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVuRCxPQUFPLEVBQUUscUNBQXFDLEVBQXFDLE1BQU0seUNBQXlDLENBQUM7QUFDbkksT0FBTyxFQUFFLCtDQUErQyxFQUFFLE1BQU0seURBQXlELENBQUM7QUFRMUgsTUFBTSxPQUFPLG9DQUFxQyxTQUFRLCtDQUErQztJQVV2RyxZQUNVLGlCQUFvQyxFQUNwQyxVQUFzQixFQUM5QixRQUFrQixFQUNxQyxpQ0FBb0U7UUFFM0gsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBTFIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUNwQyxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBRXlCLHNDQUFpQyxHQUFqQyxpQ0FBaUMsQ0FBbUM7UUFYdEgsVUFBSyxHQUFXLENBQUMsQ0FBQyxDQUFDO1FBQ25CLGdCQUFXLEdBQWlCLEVBQUUsQ0FBQztRQUMvQixTQUFJLEdBQVksS0FBSyxDQUFDO1FBRWIsZ0JBQVcsR0FBVyxrQkFBa0IsQ0FBQztRQUN4QyxpQkFBWSxHQUEwQixJQUFJLFlBQVksRUFBVyxDQUFDO1FBU2pGLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJ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QU0sQ0FBQyxHQUFHLEdBQUcsNEZBQTRGLElBQUksQ0FBQyxpQ0FBaUMsQ0FBQyxHQUFHLGFBQWEsSUFBSSxDQUFDLGlDQUFpQyxDQUFDLFFBQVEsY0FBYyxJQUFJLENBQUMsaUNBQWlDLENBQUMsU0FBUyxXQUFXLElBQUksQ0FBQyxpQ0FBaUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDeFUsTUFBTSxDQUFDLElBQUksR0FBRyxpQkFBaUIsQ0FBQztnQkFDaEMsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDcEMsQ0FBQyxDQUFDLENBQUM7O0tBQ0o7SUFFTyxLQUFLLENBQUMsT0FBZ0IsS0FBSyxFQUFFLE9BQWdCLEtBQUs7UUFDeEQsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNoQixJQUFJLENBQUMsSUFBSTtZQUFFLElBQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNsRCxDQUFDOzs7WUE3RkYsU0FBUyxTQUFDO2dCQUNULFNBQVMsRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxvQ0FBb0MsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUM7Z0JBQzNHLFFBQVEsRUFBRSxnQ0FBZ0M7Z0JBQzFDLGtqQkFBOEQ7YUFDL0Q7OztZQVhRLGlCQUFpQjtZQUFhLFVBQVU7WUFBd0IsUUFBUTs0Q0EwQjVFLE1BQU0sU0FBQyxxQ0FBcUM7OzswQkFQOUMsS0FBSzsyQkFDTCxNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbmplY3QsIEluamVjdG9yLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgTkdYX0dPT0dMRV9QTEFDRVNfQVVUT0NPTVBMRVRFX0NPTkZJRywgTmd4R29vZ2xlUGxhY2VzQXV0b2NvbXBsZXRlQ29uZmlnIH0gZnJvbSAnLi9uZ3gtZ29vZ2xlLXBsYWNlcy1hdXRvY29tcGxldGUuY29uZmlnJztcbmltcG9ydCB7IE5neEdvb2dsZVBsYWNlc0F1dG9jb21wbGV0ZUNvbnRyb2xWYWx1ZUFjY2Vzc29yIH0gZnJvbSAnLi9uZ3gtZ29vZ2xlLXBsYWNlcy1hdXRvY29tcGxldGUuY29udHJvbC12YWx1ZS1hY2Nlc3Nvcic7XG5pbXBvcnQgeyBQcmVkaWN0aW9uIH0gZnJvbSAnLi9uZ3gtZ29vZ2xlLXBsYWNlcy1hdXRvY29tcGxldGUubW9kZWxzJztcblxuQENvbXBvbmVudCh7XG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBOZ3hHb29nbGVQbGFjZXNBdXRvY29tcGxldGVDb21wb25lbnQsIG11bHRpOiB0cnVlIH1dLFxuICBzZWxlY3RvcjogJ25neC1nb29nbGUtcGxhY2VzLWF1dG9jb21wbGV0ZScsXG4gIHRlbXBsYXRlVXJsOiAnLi9uZ3gtZ29vZ2xlLXBsYWNlcy1hdXRvY29tcGxldGUuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIE5neEdvb2dsZVBsYWNlc0F1dG9jb21wbGV0ZUNvbXBvbmVudCBleHRlbmRzIE5neEdvb2dsZVBsYWNlc0F1dG9jb21wbGV0ZUNvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgcHJpdmF0ZSBzZXJ2aWNlOiBnb29nbGUubWFwcy5wbGFjZXMuQXV0b2NvbXBsZXRlU2VydmljZTtcblxuICBwdWJsaWMgaW5kZXg6IG51bWJlciA9IC0xO1xuICBwdWJsaWMgcHJlZGljdGlvbnM6IFByZWRpY3Rpb25bXSA9IFtdO1xuICBwdWJsaWMgc2hvdzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBJbnB1dCgpIHB1YmxpYyBwbGFjZWhvbGRlcjogc3RyaW5nID0gJ0VudGVyIGEgbG9jYXRpb24nO1xuICBAT3V0cHV0KCkgcHVibGljIHNjcmlwdExvYWRlZDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgQEluamVjdChOR1hfR09PR0xFX1BMQUNFU19BVVRPQ09NUExFVEVfQ09ORklHKSBwcml2YXRlIG5neEdvb2dsZVBsYWNlc0F1dG9jb21wbGV0ZUNvbmZpZzogTmd4R29vZ2xlUGxhY2VzQXV0b2NvbXBsZXRlQ29uZmlnXG4gICkge1xuICAgIHN1cGVyKGluamVjdG9yKTtcbiAgICB0aGlzLmluaXRpYWxpemUoKS50aGVuKCgpID0+IHRoaXMuc2VydmljZSA9IG5ldyBnb29nbGUubWFwcy5wbGFjZXMuQXV0b2NvbXBsZXRlU2VydmljZSgpKTtcbiAgfVxuXG4gIHB1YmxpYyBvbkJsdXIoKTogdm9pZCB7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHB1YmxpYyBvbkNsaWNrKCk6IHZvaWQge1xuICAgIHRoaXMuY29udHJvbC5zZXRWYWx1ZShudWxsKTtcbiAgfVxuXG4gIHB1YmxpYyBvbkZvY3VzKCk6IHZvaWQge1xuICAgIHRoaXMucmVzZXQodHJ1ZSwgdHJ1ZSk7XG4gIH1cblxuICBwdWJsaWMgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnNob3cpIHJldHVybjtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSAnQXJyb3dEb3duJzogdGhpcy5pbmRleCArPSAxOyBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnByZWRpY3Rpb25zLmxlbmd0aCkgdGhpcy5pbmRleCA9IHRoaXMucHJlZGljdGlvbnMubGVuZ3RoIC0gMTsgYnJlYWs7XG4gICAgICBjYXNlICdBcnJvd1VwJzogdGhpcy5pbmRleCAtPSAxOyBpZiAodGhpcy5pbmRleCA8IDApIHRoaXMuaW5kZXggPSAwOyBicmVhaztcbiAgICAgIGNhc2UgJ0VzY2FwZSc6IHRoaXMucmVzZXQodHJ1ZSk7IGJyZWFrO1xuICAgICAgY2FzZSAnRW50ZXInOiB0aGlzLmluZGV4ICE9PSAtMSA/IHRoaXMub25Nb3VzZURvd24odGhpcy5wcmVkaWN0aW9uc1t0aGlzLmluZGV4XSkgOiB0aGlzLnJlc2V0KHRydWUpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25Nb2RlbENoYW5nZShpbnB1dDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFpbnB1dCkgeyB0aGlzLnJlc2V0KCk7IHJldHVybjsgfVxuICAgIGNvbnN0IHJlcXVlc3QgPSBPYmplY3QuYXNzaWduKHsgaW5wdXQgfSwgdGhpcy5uZ3hHb29nbGVQbGFjZXNBdXRvY29tcGxldGVDb25maWcub3B0aW9ucyk7XG4gICAgdGhpcy5zZXJ2aWNlLmdldFBsYWNlUHJlZGljdGlvbnMocmVxdWVzdCwgKHByZWRpY3Rpb25zOiBQcmVkaWN0aW9uW10sIHN0YXR1czogZ29vZ2xlLm1hcHMucGxhY2VzLlBsYWNlc1NlcnZpY2VTdGF0dXMpID0+IHtcbiAgICAgIGlmIChzdGF0dXMgIT09IGdvb2dsZS5tYXBzLnBsYWNlcy5QbGFjZXNTZXJ2aWNlU3RhdHVzLk9LKSB7IHRoaXMucmVzZXQoKTsgcmV0dXJuOyB9XG4gICAgICB0aGlzLnByZWRpY3Rpb25zID0gcHJlZGljdGlvbnM7XG4gICAgICB0aGlzLnNob3cgPSB0cnVlO1xuICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgb25Nb3VzZURvd24ocHJlZGljdGlvbjogUHJlZGljdGlvbiwgZXZlbnQ/OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5jb250cm9sLnNldFZhbHVlKHByZWRpY3Rpb24uZGVzY3JpcHRpb24sIHsgZW1pdFZpZXdUb01vZGVsQ2hhbmdlOiBmYWxzZSB9KTtcbiAgICBpZiAoZXZlbnQpIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHByaXZhdGUgZGlzcGF0Y2hFdmVudChldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGxldCBjdXN0b21FdmVudDogQ3VzdG9tRXZlbnQ7XG4gICAgaWYgKHdpbmRvdy5DdXN0b21FdmVudCkge1xuICAgICAgY3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3N1Ym1pdCcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSwgZGV0YWlsOiBldmVudCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9tRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGN1c3RvbUV2ZW50LmluaXRDdXN0b21FdmVudCgnc3VibWl0JywgdHJ1ZSwgdHJ1ZSwgeyBkYXRhOiBldmVudCB9KTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuZm9ybS5kaXNwYXRjaEV2ZW50KGN1c3RvbUV2ZW50KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAod2luZG93Lmdvb2dsZT8ubWFwcykgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXNvbHZlKCkpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB3aW5kb3dbJ25neEdvb2dsZVBsYWNlc0F1dG9jb21wbGV0ZUNhbGxiYWNrJ10gPSAoKSA9PiB7IHRoaXMuc2NyaXB0TG9hZGVkLmVtaXQodHJ1ZSk7IHJlc29sdmUoKTsgfTtcbiAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gICAgICBzY3JpcHQub25lcnJvciA9IChlcnIpID0+IHJlamVjdChlcnIpO1xuICAgICAgc2NyaXB0LnNyYyA9IGBodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanM/Y2FsbGJhY2s9bmd4R29vZ2xlUGxhY2VzQXV0b2NvbXBsZXRlQ2FsbGJhY2sma2V5PSR7dGhpcy5uZ3hHb29nbGVQbGFjZXNBdXRvY29tcGxldGVDb25maWcua2V5fSZsYW5ndWFnZT0ke3RoaXMubmd4R29vZ2xlUGxhY2VzQXV0b2NvbXBsZXRlQ29uZmlnLmxhbmd1YWdlfSZsaWJyYXJpZXM9JHt0aGlzLm5neEdvb2dsZVBsYWNlc0F1dG9jb21wbGV0ZUNvbmZpZy5saWJyYXJpZXN9JnJlZ2lvbj0ke3RoaXMubmd4R29vZ2xlUGxhY2VzQXV0b2NvbXBsZXRlQ29uZmlnLnJlZ2lvbn1gO1xuICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXQoa2VlcDogYm9vbGVhbiA9IGZhbHNlLCBzaG93OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgaWYgKCFrZWVwKSB0aGlzLnByZWRpY3Rpb25zID0gW107XG4gICAgdGhpcy5zaG93ID0gc2hvdyAmJiB0aGlzLnByZWRpY3Rpb25zLmxlbmd0aCA+IDA7XG4gIH1cbn0iXX0=