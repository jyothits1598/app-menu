import { __awaiter } from 'tslib';
import { InjectionToken, Input, ViewChild, EventEmitter, Component, ChangeDetectorRef, ElementRef, Injector, Inject, Output, Pipe, NgModule } from '@angular/core';
import { ControlContainer, FormControlDirective, NG_VALUE_ACCESSOR, ReactiveFormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/forms';
import * as ɵngcc2 from '@angular/common';

function NgxGooglePlacesAutocompleteComponent_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 3);
    ɵngcc0.ɵɵlistener("click", function NgxGooglePlacesAutocompleteComponent_button_2_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick(); });
    ɵngcc0.ɵɵtext(1, "\u00D7");
    ɵngcc0.ɵɵelementEnd();
} }
function NgxGooglePlacesAutocompleteComponent_ul_3_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 5);
    ɵngcc0.ɵɵlistener("mousedown", function NgxGooglePlacesAutocompleteComponent_ul_3_li_1_Template_li_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const prediction_r5 = ctx.$implicit; const ctx_r7 = ɵngcc0.ɵɵnextContext(2); return ctx_r7.onMouseDown(prediction_r5, $event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const prediction_r5 = ctx.$implicit;
    const i_r6 = ctx.index;
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassProp("selected", i_r6 === ctx_r4.index);
    ɵngcc0.ɵɵproperty("innerHTML", prediction_r5.innerHTML, ɵngcc0.ɵɵsanitizeHtml);
} }
function NgxGooglePlacesAutocompleteComponent_ul_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "ul");
    ɵngcc0.ɵɵtemplate(1, NgxGooglePlacesAutocompleteComponent_ul_3_li_1_Template, 1, 3, "li", 4);
    ɵngcc0.ɵɵpipe(2, "highlight");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r1.predictions));
} }
const NGX_GOOGLE_PLACES_AUTOCOMPLETE_CONFIG = new InjectionToken('NGX_GOOGLE_PLACES_AUTOCOMPLETE_CONFIG');

class NgxGooglePlacesAutocompleteControlValueAccessor {
    constructor(injector) {
        this.injector = injector;
    }
    get control() {
        return this.formControl || this.controlContainer.control.get(this.formControlName);
    }
    get controlContainer() {
        return this.injector.get(ControlContainer);
    }
    registerOnChange(fn) {
        this.formControlDirective.valueAccessor.registerOnChange(fn);
    }
    registerOnTouched(fn) {
        this.formControlDirective.valueAccessor.registerOnTouched(fn);
    }
    setDisabledState(isDisabled) {
        this.formControlDirective.valueAccessor.setDisabledState(isDisabled);
    }
    writeValue(obj) {
        this.formControlDirective.valueAccessor.writeValue(obj);
    }
}
NgxGooglePlacesAutocompleteControlValueAccessor.ɵfac = function NgxGooglePlacesAutocompleteControlValueAccessor_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
NgxGooglePlacesAutocompleteControlValueAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxGooglePlacesAutocompleteControlValueAccessor, viewQuery: function NgxGooglePlacesAutocompleteControlValueAccessor_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(FormControlDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.formControlDirective = _t.first);
    } }, inputs: { formControl: "formControl", formControlName: "formControlName" } });
NgxGooglePlacesAutocompleteControlValueAccessor.propDecorators = {
    formControl: [{ type: Input }],
    formControlName: [{ type: Input }],
    formControlDirective: [{ type: ViewChild, args: [FormControlDirective, { static: true },] }]
};


class NgxGooglePlacesAutocompleteComponent extends NgxGooglePlacesAutocompleteControlValueAccessor {
    constructor(changeDetectorRef, elementRef, injector, ngxGooglePlacesAutocompleteConfig) {
        super(injector);
        this.changeDetectorRef = changeDetectorRef;
        this.elementRef = elementRef;
        this.ngxGooglePlacesAutocompleteConfig = ngxGooglePlacesAutocompleteConfig;
        this.index = -1;
        this.predictions = [];
        this.show = false;
        this.placeholder = 'Enter a location';
        this.scriptLoaded = new EventEmitter();
        this.initialize().then(() => this.service = new google.maps.places.AutocompleteService());
    }
    onBlur() {
        this.reset(true);
    }
    onClick() {
        this.control.setValue(null);
    }
    onFocus() {
        this.reset(true, true);
    }
    onKeyDown(event) {
        if (!this.show)
            return;
        switch (event.key) {
            case 'ArrowDown':
                this.index += 1;
                if (this.index >= this.predictions.length)
                    this.index = this.predictions.length - 1;
                break;
            case 'ArrowUp':
                this.index -= 1;
                if (this.index < 0)
                    this.index = 0;
                break;
            case 'Escape':
                this.reset(true);
                break;
            case 'Enter':
                this.index !== -1 ? this.onMouseDown(this.predictions[this.index]) : this.reset(true);
                break;
        }
    }
    onModelChange(input) {
        if (!input) {
            this.reset();
            return;
        }
        const request = Object.assign({ input }, this.ngxGooglePlacesAutocompleteConfig.options);
        this.service.getPlacePredictions(request, (predictions, status) => {
            if (status !== google.maps.places.PlacesServiceStatus.OK) {
                this.reset();
                return;
            }
            this.predictions = predictions;
            this.show = true;
            this.changeDetectorRef.detectChanges();
        });
    }
    onMouseDown(prediction, event) {
        this.control.setValue(prediction.description, { emitViewToModelChange: false });
        if (event)
            this.dispatchEvent(event);
        this.reset(true);
    }
    dispatchEvent(event) {
        let customEvent;
        if (window.CustomEvent) {
            customEvent = new CustomEvent('submit', { bubbles: true, cancelable: true, detail: event });
        }
        else {
            customEvent = document.createEvent('CustomEvent');
            customEvent.initCustomEvent('submit', true, true, { data: event });
        }
        this.elementRef.nativeElement.firstElementChild.firstElementChild.form.dispatchEvent(customEvent);
    }
    initialize() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = window.google) === null || _a === void 0 ? void 0 : _a.maps)
                return new Promise((resolve) => resolve());
            return new Promise((resolve, reject) => {
                window['ngxGooglePlacesAutocompleteCallback'] = () => { this.scriptLoaded.emit(true); resolve(); };
                const script = document.createElement('script');
                script.async = true;
                script.defer = true;
                script.onerror = (err) => reject(err);
                script.src = `https://maps.googleapis.com/maps/api/js?callback=ngxGooglePlacesAutocompleteCallback&key=${this.ngxGooglePlacesAutocompleteConfig.key}&language=${this.ngxGooglePlacesAutocompleteConfig.language}&libraries=${this.ngxGooglePlacesAutocompleteConfig.libraries}&region=${this.ngxGooglePlacesAutocompleteConfig.region}`;
                script.type = 'text/javascript';
                document.body.appendChild(script);
            });
        });
    }
    reset(keep = false, show = false) {
        this.index = -1;
        if (!keep)
            this.predictions = [];
        this.show = show && this.predictions.length > 0;
    }
}
NgxGooglePlacesAutocompleteComponent.ɵfac = function NgxGooglePlacesAutocompleteComponent_Factory(t) { return new (t || NgxGooglePlacesAutocompleteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(NGX_GOOGLE_PLACES_AUTOCOMPLETE_CONFIG)); };
NgxGooglePlacesAutocompleteComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxGooglePlacesAutocompleteComponent, selectors: [["ngx-google-places-autocomplete"]], inputs: { placeholder: "placeholder" }, outputs: { scriptLoaded: "scriptLoaded" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: NgxGooglePlacesAutocompleteComponent, multi: true }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 4, consts: [["autocomplete", "off", "type", "text", 3, "formControl", "placeholder", "blur", "focus", "keydown", "ngModelChange"], ["type", "button", 3, "click", 4, "ngIf"], [4, "ngIf"], ["type", "button", 3, "click"], [3, "selected", "innerHTML", "mousedown", 4, "ngFor", "ngForOf"], [3, "innerHTML", "mousedown"]], template: function NgxGooglePlacesAutocompleteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelementStart(1, "input", 0);
        ɵngcc0.ɵɵlistener("blur", function NgxGooglePlacesAutocompleteComponent_Template_input_blur_1_listener() { return ctx.onBlur(); })("focus", function NgxGooglePlacesAutocompleteComponent_Template_input_focus_1_listener() { return ctx.onFocus(); })("keydown", function NgxGooglePlacesAutocompleteComponent_Template_input_keydown_1_listener($event) { return ctx.onKeyDown($event); })("ngModelChange", function NgxGooglePlacesAutocompleteComponent_Template_input_ngModelChange_1_listener($event) { return ctx.onModelChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NgxGooglePlacesAutocompleteComponent_button_2_Template, 2, 0, "button", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, NgxGooglePlacesAutocompleteComponent_ul_3_Template, 3, 3, "ul", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("formControl", ctx.control)("placeholder", ctx.placeholder);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.control.value);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.show);
    } }, directives: function () { return [ɵngcc1.DefaultValueAccessor, ɵngcc1.NgControlStatus, ɵngcc1.FormControlDirective, ɵngcc2.NgIf, ɵngcc2.NgForOf]; }, pipes: function () { return [NgxGooglePlacesAutocompletePipe]; }, encapsulation: 2 });
NgxGooglePlacesAutocompleteComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: [NGX_GOOGLE_PLACES_AUTOCOMPLETE_CONFIG,] }] }
];
NgxGooglePlacesAutocompleteComponent.propDecorators = {
    placeholder: [{ type: Input }],
    scriptLoaded: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxGooglePlacesAutocompleteComponent, [{
        type: Component,
        args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: NgxGooglePlacesAutocompleteComponent, multi: true }],
                selector: 'ngx-google-places-autocomplete',
                template: "<div>\n  <input autocomplete=\"off\" (blur)=\"onBlur()\" (focus)=\"onFocus()\" [formControl]=\"control\" (keydown)=\"onKeyDown($event)\" (ngModelChange)=\"onModelChange($event)\" [placeholder]=\"placeholder\" type=\"text\" />\n  <button (click)=\"onClick()\" *ngIf=\"control.value\" type=\"button\">&times;</button>\n</div>\n<ul *ngIf=\"show\">\n  <li [class.selected]=\"i === index\" [innerHTML]=\"prediction.innerHTML\" (mousedown)=\"onMouseDown(prediction, $event)\" *ngFor=\"let prediction of predictions | highlight; let i = index\"></li>\n</ul>"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Injector }, { type: undefined, decorators: [{
                type: Inject,
                args: [NGX_GOOGLE_PLACES_AUTOCOMPLETE_CONFIG]
            }] }]; }, { placeholder: [{
            type: Input
        }], scriptLoaded: [{
            type: Output
        }] }); })();

class NgxGooglePlacesAutocompletePipe {
    transform(predictions) {
        var _a;
        for (const prediction of predictions) {
            prediction.innerHTML = prediction.description;
            for (let i = 0; i < ((_a = prediction.matched_substrings) === null || _a === void 0 ? void 0 : _a.length); i += 1) {
                const offset = prediction.matched_substrings[i].offset + i * 17;
                const length = prediction.matched_substrings[i].length + offset;
                prediction.innerHTML =
                    `${prediction.innerHTML.slice(0, offset)}<strong>${prediction.innerHTML.slice(offset, length)}</strong>${prediction.innerHTML.slice(length)}`;
            }
        }
        return predictions;
    }
}
NgxGooglePlacesAutocompletePipe.ɵfac = function NgxGooglePlacesAutocompletePipe_Factory(t) { return new (t || NgxGooglePlacesAutocompletePipe)(); };
NgxGooglePlacesAutocompletePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "highlight", type: NgxGooglePlacesAutocompletePipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxGooglePlacesAutocompletePipe, [{
        type: Pipe,
        args: [{ name: 'highlight' }]
    }], null, null); })();

class NgxGooglePlacesAutocompleteModule {
    static forRoot(ngxGooglePlacesAutocompleteConfig) {
        return {
            ngModule: NgxGooglePlacesAutocompleteModule,
            providers: [{ provide: NGX_GOOGLE_PLACES_AUTOCOMPLETE_CONFIG, useValue: ngxGooglePlacesAutocompleteConfig }]
        };
    }
}
NgxGooglePlacesAutocompleteModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxGooglePlacesAutocompleteModule });
NgxGooglePlacesAutocompleteModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxGooglePlacesAutocompleteModule_Factory(t) { return new (t || NgxGooglePlacesAutocompleteModule)(); }, imports: [[CommonModule, ReactiveFormsModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxGooglePlacesAutocompleteModule, { declarations: function () { return [NgxGooglePlacesAutocompleteComponent,
        NgxGooglePlacesAutocompletePipe]; }, imports: function () { return [CommonModule, ReactiveFormsModule]; }, exports: function () { return [NgxGooglePlacesAutocompleteComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxGooglePlacesAutocompleteModule, [{
        type: NgModule,
        args: [{
                declarations: [NgxGooglePlacesAutocompleteComponent, NgxGooglePlacesAutocompletePipe],
                exports: [NgxGooglePlacesAutocompleteComponent],
                imports: [CommonModule, ReactiveFormsModule]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { NGX_GOOGLE_PLACES_AUTOCOMPLETE_CONFIG, NgxGooglePlacesAutocompleteComponent, NgxGooglePlacesAutocompleteModule, NgxGooglePlacesAutocompleteControlValueAccessor as ɵa, NgxGooglePlacesAutocompletePipe as ɵb };

//# sourceMappingURL=codious-ngx-google-places-autocomplete.js.map